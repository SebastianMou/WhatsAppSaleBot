from google import genai
from django.conf import settings
from .models import WhatsAppMessage, WhatsAppContact
import logging

logger = logging.getLogger(__name__)

class WhatsAppAIService:
    def __init__(self):
        try:
            # Configure new Gemini client
            if not hasattr(settings, 'GEMINI_API_KEY') or not settings.GEMINI_API_KEY:
                raise ValueError("GEMINI_API_KEY not found in Django settings")
            
            self.client = genai.Client(api_key=settings.GEMINI_API_KEY)
            logger.info("Gemini AI service initialized successfully with new API")
        except Exception as e:
            logger.error(f"Failed to initialize Gemini AI: {str(e)}")
            raise
    
    def generate_response(self, contact_id, max_messages=50):
        """
        Generate an AI response based on conversation history for a specific contact
        Each conversation is isolated - no cross-conversation contamination
        """
        try:
            logger.info(f"Generating response for contact_id: {contact_id}")
            
            # Get contact and recent messages
            try:
                contact = WhatsAppContact.objects.get(id=contact_id)
                logger.info(f"Found contact: {contact.name or contact.phone_number}")
            except WhatsAppContact.DoesNotExist:
                logger.error(f"Contact with id {contact_id} not found")
                return {
                    'success': False,
                    'error': f'Contact with id {contact_id} not found'
                }
            
            # Get messages for THIS SPECIFIC CONTACT ONLY
            messages = WhatsAppMessage.objects.filter(
                contact=contact
            ).order_by('-timestamp')[:max_messages]

            
            logger.info(f"Found {len(messages)} messages for contact {contact_id}")
            
            # Build conversation context (isolated to this contact)
            conversation_history = []
            for message in reversed(messages):  # Reverse to get chronological order
                role = "Cliente" if message.is_incoming else "Sebastian"
                conversation_history.append(f"{role}: {message.content}")
            
            if not conversation_history:
                logger.warning(f"No conversation history found for contact {contact_id}")
                return {
                    'success': False,
                    'error': 'No conversation history found'
                }
            
            # Create the prompt with IZZI instructions
            prompt = self.build_izzi_prompt(contact, conversation_history)
            logger.info(f"Built IZZI prompt for contact {contact_id}, conversation length: {len(conversation_history)}")
            
            # Generate response using NEW Gemini API
            try:
                response = self.client.models.generate_content(
                    model="gemini-2.0-flash",
                    contents=[prompt]
                )
                logger.info("Successfully generated AI response")
            except Exception as e:
                logger.error(f"Gemini API error: {str(e)}")
                return {
                    'success': False,
                    'error': f'AI generation failed: {str(e)}'
                }
            
            if response.text:
                print(f"\nü§ñ AI RESPONSE PREVIEW:")
                print(f"üì§ Generated: {response.text[:100]}...")  # First 100 characters
                print(f"üìè Length: {len(response.text)} characters")

                return {
                    'success': True,
                    'response': response.text.strip(),
                    'conversation_length': len(conversation_history),
                    'contact_id': contact_id
                }
            else:
                logger.warning("Gemini returned empty response")
                return {
                    'success': False,
                    'error': 'No response generated by AI'
                }
                
        except Exception as e:
            logger.error(f"AI Service Error for contact {contact_id}: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def build_izzi_prompt(self, contact, conversation_history):
        """
        Build the AI prompt with IZZI-specific context and instructions
        This ensures the AI follows IZZI sales process and guidelines
        """
        contact_name = contact.name or contact.phone_number
        personality_type = self.detect_personality_type(conversation_history)
        
        try:
            aida_stage = self.detect_aida_stage(conversation_history)
        except AttributeError:
            aida_stage = 'Interest'  # Default fallback
            print("detect_aida_stage method not found, using fallback")

        conversation_summary = self.build_conversation_summary(conversation_history)

        print(f"\nüîç === AI ANALYSIS FOR {contact_name} ===")
        print(f"üìä Personality Type: {personality_type}")
        print(f"üéØ AIDA Stage: {aida_stage}")
        print(f"üìù Conversation Summary: {conversation_summary}")
        print(f"üí¨ Recent Messages: {conversation_history[-3:]}")  # Show last 3 messages
        print(f"üî¢ Total Messages: {len(conversation_history)}")
        print("=" * 50)

        personality_styles = {
            'D': {
                'style': 'Directo, enfocado en resultados, sin rodeos',
                'example': '"Este paquete es el m√°s potente. Te da el mejor internet sin rodeos."'
            },
            'I': {
                'style': 'Amigable, social, usa emojis ocasionales',
                'example': '"¬°Perfecto para ver series y compartir con toda la familia! üòÑüì∂"'
            },
            'S': {
                'style': 'Tranquilizador, enfocado en confiabilidad',
                'example': '"Servicio confiable, sin interrupciones y soporte 24/7 incluido."'
            },
            'C': {
                'style': 'Detallado, l√≥gico, con informaci√≥n t√©cnica',
                'example': '"Te explico las especificaciones t√©cnicas de cada paquete para que elijas el mejor."'
            }
        }

        prompt = f"""
            ## Instrucciones Chatbot Ventas IZZI - FRAMEWORK AIDA + PERSONALIDAD

            ### Identidad
            - Eres Sebastian Mauricio, asesor de IZZI especialista en ventas por WhatsApp
            - Combinas framework AIDA + personalidad del cliente + proceso de venta estructurado

            ### AN√ÅLISIS DEL CLIENTE:
            - **Cliente:** {contact_name}
            - **Personalidad:** {personality_type} | **Etapa AIDA:** {aida_stage}
            - **Estilo:** {personality_styles[personality_type]['style']}

            ### üéØ DETECCI√ìN INTELIGENTE DE INTENCI√ìN:
            **ANALIZA si el cliente es:**
            - **PRECIO-ENFOCADO**: Busca "barato", "econ√≥mico", "presupuesto bajo", o pregunta directamente precios SIN mencionar necesidades espec√≠ficas
            - **CONSULTIVO**: Pregunta "qu√© me recomienda", menciona familia/dispositivos/necesidades espec√≠ficas
            
            ### FRAMEWORK AIDA POR PERSONALIDAD:
            **ATENCI√ìN:** D="¬øBuscas el mejor internet? Oferta directa." | I="¬°Hola! üòä ¬øInternet para toda la familia?" | S="¬øProblemas con tu internet? Soluci√≥n confiable." | C="¬øM√°s velocidad? Paquetes t√©cnicamente superiores."

            ### Paquetes IZZI (mantener precios exactos)
            - **2P (6 meses promoci√≥n):** 
            60MB (+80MB adicionales) Precio de lista $389, promoci√≥n de 3 meses $349
            80MB (+100MB adicionales) Precio de lista $510, promoci√≥n de 3 meses $419
            100MB (+150MB adicionales) Precio de lista $540, promoci√≥n de 3 meses $439
            150MB (+200MB adicionales) Precio de lista $610, promoci√≥n de 3 meses $509
            200MB (+500MB adicionales) Precio de lista $670, promoci√≥n de 3 meses $569
            500MB (+1000MB adicionales) Precio de lista $790, promoci√≥n de 3 meses $689
            1000MB Precio de lista $990, promoci√≥n de 3 meses $889

            - **3P (6 meses promoci√≥n):** 
            60MB (+80MB adicionales) Precio de lista $539, promoci√≥n de 6 meses $499
            80MB (+100MB adicionales) Precio de lista $690, promoci√≥n de 6 meses $599
            100MB (+150MB adicionales) Precio de lista $720, promoci√≥n de 6 meses $619
            150MB (+200MB adicionales) Precio de lista $790, promoci√≥n de 6 meses $689
            200MB (+500MB adicionales) Precio de lista $850, promoci√≥n de 6 meses $749
            500MB (+1000MB adicionales) Precio de lista $970, promoci√≥n de 6 meses $869
            1000MB Precio de lista $1,170, promoci√≥n de 6 meses $1,069
            
            **SI CLIENTE ES PRECIO-ENFOCADO:**
            1. Saluda seg√∫n personalidad {personality_type}
            2. **OFRECE INMEDIATAMENTE**: "El m√°s econ√≥mico es 60MB (+80MB adicionales) por $349 los primeros 3 meses, perfecto para WhatsApp y redes sociales"
            3. Solicita ubicaci√≥n: "Presiona clip (üìé) ‚Üí 'Ubicaci√≥n' para compartir ubicaci√≥n actual"
            4. Si acepta ‚Üí Solicita documentaci√≥n directamente
            5. **NO hagas muchas preguntas** - ya decidi√≥ que quiere lo barato

            **SI CLIENTE ES CONSULTIVO (Normal):**
            1. Saluda seg√∫n personalidad {personality_type} y pregunta servicio actual
            2. **SOLICITA UBICACI√ìN EXACTA:** "Presiona clip (üìé) ‚Üí 'Ubicaci√≥n' para compartir ubicaci√≥n actual"
            3. Al recibir ubicaci√≥n: confirma y agradece
            4. **PREGUNTAS NECESIDADES:** dispositivos, uso, personas, presupuesto, servicios adicionales
            5. **RECOMIENDA PAQUETE** espec√≠fico con precio exacto
            6. **Si acepta:** Solicita documentaci√≥n:
            "Para continuar necesito:
            üë§ Nombre completo titular
            üè† Comprobante domicilio  
            ü™™ INE (frente y reverso)
            üì± Tel√©fono titular
            üìû Tel√©fono referido
            üìß Correo electr√≥nico"

            ### üí∞ PAQUETE M√ÅS ECON√ìMICO (Para precio-enfocados):
            **60MB (+80MB adicionales)** - $349 por 3 meses (precio regular $389)
            - Perfecto para WhatsApp, redes sociales, navegaci√≥n b√°sica
            - Instalaci√≥n GRATIS incluida

            ### Promociones: Instalaci√≥n GRATIS, MAX 12 meses, Apple TV+, VIX Premium, Domizzilia -$50/mes, Portabilidad, Sin plazos. TV+ $299, M√≥vil +$79.
            ### Adicional
            - Izzi TV+ $299 (200 canales) con Sky Sports incluido
            - Promoci√≥n con M√≥vil $79 Extra

            **Resumen:** {chr(10).join(conversation_summary) if conversation_summary else "Primera conversaci√≥n"}
            **Recientes:** {chr(10).join(conversation_history[-10:]) if conversation_history else "Inicio"}

            ### INSTRUCCIONES:
            - Responde como {personality_type} en etapa {aida_stage}
            - Sigue proceso de venta paso a paso
            - Si cliente comparti√≥ ubicaci√≥n (Google Maps link), recon√≥celo y contin√∫a con preguntas de necesidades
            - M√°ximo 2-3 oraciones
            - {personality_type}='I' usa 1 emoji ocasional

            Respuesta Sebastian Mauricio:
            """
        
        return prompt
    
    def generate_multiple_responses(self, contact_id, count=3):
        """
        Generate multiple response options for the same conversation
        All responses are based on the SAME isolated conversation
        """
        responses = []
        for i in range(count):
            logger.info(f"Generating response {i+1}/{count} for contact {contact_id}")
            result = self.generate_response(contact_id)
            if result['success']:
                responses.append(result['response'])
            else:
                # If one fails, try a fallback response
                responses.append(self.get_izzi_fallback_response())
        
        return {
            'success': True,
            'responses': responses,
            'contact_id': contact_id
        }
    
    def get_izzi_fallback_response(self):
        """
        IZZI-specific fallback responses when AI fails
        """
        fallbacks = [
            "¬°Hola! üëã ¬øActualmente cuentas con una compa√±√≠a o servicio de internet?",
            "¬°Hola! Soy Sebastian de IZZI. ¬øTe interesa conocer nuestros paquetes de internet? üì±",
            "¬°Hola! ¬øC√≥mo est√°s? ¬øActualmente tienes servicio de internet en casa?"
        ]
        import random
        return random.choice(fallbacks)
    
    # Keep the original build_prompt method for backward compatibility if needed
    def build_prompt(self, contact, conversation_history):
        """
        Original generic prompt builder (kept for compatibility)
        Use build_izzi_prompt for IZZI-specific conversations
        """
        return self.build_izzi_prompt(contact, conversation_history)
    
    def build_conversation_summary(self, conversation_history):
        """Build a summary of key conversation points"""
        full_conversation = '\n'.join(conversation_history)
        
        summary_points = []
        
        # Check if client mentioned current internet service
        if any('megacable' in msg.lower() or 'totalplay' in msg.lower() or 'telmex' in msg.lower() or 'izzi' in msg.lower() for msg in conversation_history):
            summary_points.append("- Cliente ya mencion√≥ su servicio actual de internet")
        
        # Check if location was shared
        if any('ubicaci√≥n compartida' in msg.lower() or 'google.com/maps' in msg.lower() for msg in conversation_history):
            summary_points.append("- Cliente ya comparti√≥ su ubicaci√≥n")
        
        # Check if package was selected
        if any('3p' in msg.lower() or 'paquete' in msg.lower() or '$' in msg for msg in conversation_history):
            summary_points.append("- Cliente ya mostr√≥ inter√©s en un paquete espec√≠fico")
        
        # Check if client provided personal data
        if any('@' in msg and '.com' in msg for msg in conversation_history):
            summary_points.append("- Cliente ya proporcion√≥ informaci√≥n personal")
        
        return summary_points
    
    def detect_personality_type(self, conversation_history):
        """Detect customer personality type based on conversation patterns"""
        full_conversation = ' '.join(conversation_history).lower()
        
        # Dominant (D) - Direct, price-focused, short messages
        dominant_indicators = [
            'precio', 'cuanto cuesta', 'rapido', 'ya', 'directo', 'mejor oferta',
            'barato', 'm√°s barato', 'no quiero', 'honestamente', 'nada m√°s', 
            'solo quiero', 'necesito', 'quiero ya', 'ahora mismo', 'sin rodeos',
            'directo al grano', 'r√°pido', 'inmediato', 'decidido', 'listo'
        ]
        dominant_score = sum(1 for indicator in dominant_indicators if indicator in full_conversation)
        
        # Influential (I) - Friendly, uses emojis, social language
        influential_indicators = [
            'familia', 'amigos', 'compartir', 'genial', 'perfecto', 'gracias',
            'excelente', 'incre√≠ble', 'fant√°stico', 'buen√≠simo', 'padre', 'chido',
            'qu√© bueno', 'me gusta', 'suena bien', 'est√° padre', 'qu√© padre',
            'social', 'todos', 'juntos', 'hijos', 'esposa', 'pareja'
        ]
        influential_score = sum(1 for indicator in influential_indicators if indicator in full_conversation)
        emoji_count = (full_conversation.count('üòÑ') + full_conversation.count('üëç') + 
               full_conversation.count('üòä') + full_conversation.count('üòÅ') + 
               full_conversation.count('ü§ó') + full_conversation.count('üëå') +
               full_conversation.count('üí™') + full_conversation.count('üéâ'))
        influential_score += emoji_count
        
        # Steady (S) - Asks about reliability, service quality
        steady_indicators = [
            'servicio', 'confiable', 'problemas', 'soporte', 'calidad', 'estable',
            'seguro', 'garant√≠a', 'respaldo', 'apoyo', 'ayuda', 'asistencia',
            'funciona bien', 'sin problemas', 'constante', 'duradero', 'fijo',
            'preocupa', 'dudas', 'seguridad', 'confianza', 'tranquilo'
        ]
        steady_score = sum(1 for indicator in steady_indicators if indicator in full_conversation)
        
        # Conscientious (C) - Technical questions, wants details
        conscientious_indicators = [
            'mbps', 'velocidad', 'tecnico', 'especificaciones', 'comparacion', 'diferencia',
            'detalles', 'informaci√≥n', 'datos', 'n√∫meros', 'estad√≠sticas', 'an√°lisis',
            'qu√© incluye', 'c√≥mo funciona', 'explicaci√≥n', 'documentaci√≥n', 
            't√©rminos', 'condiciones', 'contrato', 'letra peque√±a', 'opciones'
        ]
        conscientious_score = sum(1 for indicator in conscientious_indicators if indicator in full_conversation)
        
        # Determine dominant personality
        scores = {
            'D': dominant_score,
            'I': influential_score, 
            'S': steady_score,
            'C': conscientious_score
        }

        print(f"üß† PERSONALITY SCORES:")
        print(f"   D (Dominant): {dominant_score}")
        print(f"   I (Influential): {influential_score}")  
        print(f"   S (Steady): {steady_score}")
        print(f"   C (Conscientious): {conscientious_score}")
        
        detected_type = max(scores, key=scores.get) if max(scores.values()) > 0 else 'I'
        print(f"   ‚úÖ DETECTED: {detected_type}")

        return max(scores, key=scores.get) if max(scores.values()) > 0 else 'I'  # Default to Influential
    
def detect_aida_stage(self, conversation_history):
    """Detect current AIDA stage based on conversation"""
    full_conversation = ' '.join(conversation_history).lower()
    
    # Action - Client ready to proceed, gave info, or accepted package
    if any(indicator in full_conversation for indicator in ['acepto', 'ok', 'si quiero', 'cuando vienen', 'cuanto tiempo']):
        return 'Action'
    
    # Desire - Asking about specific packages, prices, or showing strong interest
    if any(indicator in full_conversation for indicator in ['paquete', 'precio', 'cuanto cuesta', 'me interesa', '$']):
        return 'Desire'
    
    # Interest - Engaged, asking questions, shared location
    if any(indicator in full_conversation for indicator in ['ubicacion', 'cobertura', 'como funciona', 'que incluye']):
        return 'Interest'
    
    # Attention - Just starting conversation
    return 'Attention'