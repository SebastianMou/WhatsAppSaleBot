from google import genai
from django.conf import settings
from .models import WhatsAppMessage, WhatsAppContact
import logging

logger = logging.getLogger(__name__)

class WhatsAppAIService:
    def __init__(self):
        try:
            # Configure new Gemini client
            if not hasattr(settings, 'GEMINI_API_KEY') or not settings.GEMINI_API_KEY:
                raise ValueError("GEMINI_API_KEY not found in Django settings")
            
            self.client = genai.Client(api_key=settings.GEMINI_API_KEY)
            logger.info("Gemini AI service initialized successfully with new API")
        except Exception as e:
            logger.error(f"Failed to initialize Gemini AI: {str(e)}")
            raise
    
    def generate_response(self, contact_id, max_messages=50):
        """
        Generate an AI response based on conversation history for a specific contact
        Each conversation is isolated - no cross-conversation contamination
        """
        try:
            logger.info(f"Generating response for contact_id: {contact_id}")
            
            # Get contact and recent messages
            try:
                contact = WhatsAppContact.objects.get(id=contact_id)
                logger.info(f"Found contact: {contact.name or contact.phone_number}")
            except WhatsAppContact.DoesNotExist:
                logger.error(f"Contact with id {contact_id} not found")
                return {
                    'success': False,
                    'error': f'Contact with id {contact_id} not found'
                }
            
            # Get messages for THIS SPECIFIC CONTACT ONLY
            messages = WhatsAppMessage.objects.filter(
                contact=contact
            ).order_by('-timestamp')[:max_messages]

            
            logger.info(f"Found {len(messages)} messages for contact {contact_id}")
            
            # Build conversation context (isolated to this contact)
            conversation_history = []
            for message in reversed(messages):  # Reverse to get chronological order
                role = "Cliente" if message.is_incoming else "Sebastian"
                conversation_history.append(f"{role}: {message.content}")
            
            if not conversation_history:
                logger.warning(f"No conversation history found for contact {contact_id}")
                return {
                    'success': False,
                    'error': 'No conversation history found'
                }
            
            # Create the prompt with IZZI instructions
            prompt = self.build_izzi_prompt(contact, conversation_history)
            logger.info(f"Built IZZI prompt for contact {contact_id}, conversation length: {len(conversation_history)}")
            
            # Generate response using NEW Gemini API
            try:
                response = self.client.models.generate_content(
                    model="gemini-2.0-flash",
                    contents=[prompt]
                )
                logger.info("Successfully generated AI response")
            except Exception as e:
                logger.error(f"Gemini API error: {str(e)}")
                return {
                    'success': False,
                    'error': f'AI generation failed: {str(e)}'
                }
            
            if response.text:
                print(f"\nðŸ¤– AI RESPONSE PREVIEW:")
                print(f"ðŸ“¤ Generated: {response.text[:100]}...")  # First 100 characters
                print(f"ðŸ“ Length: {len(response.text)} characters")

                return {
                    'success': True,
                    'response': response.text.strip(),
                    'conversation_length': len(conversation_history),
                    'contact_id': contact_id
                }
            else:
                logger.warning("Gemini returned empty response")
                return {
                    'success': False,
                    'error': 'No response generated by AI'
                }
                
        except Exception as e:
            logger.error(f"AI Service Error for contact {contact_id}: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def build_izzi_prompt(self, contact, conversation_history):
        """
        Build the AI prompt with IZZI-specific context and instructions
        This ensures the AI follows IZZI sales process and guidelines
        """
        contact_name = contact.name or contact.phone_number
        personality_type = self.detect_personality_type(conversation_history)
        
        try:
            aida_stage = self.detect_aida_stage(conversation_history)
        except AttributeError:
            aida_stage = 'Interest'  # Default fallback
            print("detect_aida_stage method not found, using fallback")

        conversation_summary = self.build_conversation_summary(conversation_history)

        print(f"\nðŸ” === AI ANALYSIS FOR {contact_name} ===")
        print(f"ðŸ“Š Personality Type: {personality_type}")
        print(f"ðŸŽ¯ AIDA Stage: {aida_stage}")
        print(f"ðŸ“ Conversation Summary: {conversation_summary}")
        print(f"ðŸ’¬ Recent Messages: {conversation_history[-3:]}")  # Show last 3 messages
        print(f"ðŸ”¢ Total Messages: {len(conversation_history)}")
        print("=" * 50)

        personality_styles = {
            'D': {
                'style': 'Directo, enfocado en resultados, sin rodeos',
                'example': '"Este paquete es el mÃ¡s potente. Te da el mejor internet sin rodeos."'
            },
            'I': {
                'style': 'Amigable, social, usa emojis ocasionales',
                'example': '"Â¡Perfecto para ver series y compartir con toda la familia! ðŸ˜„ðŸ“¶"'
            },
            'S': {
                'style': 'Tranquilizador, enfocado en confiabilidad',
                'example': '"Servicio confiable, sin interrupciones y soporte 24/7 incluido."'
            },
            'C': {
                'style': 'Detallado, lÃ³gico, con informaciÃ³n tÃ©cnica',
                'example': '"Te explico las especificaciones tÃ©cnicas de cada paquete para que elijas el mejor."'
            }
        }

        prompt = f"""
            ## Instrucciones Chatbot Ventas IZZI - FRAMEWORK AIDA + PERSONALIDAD

            ### Identidad
            - Eres Sebastian Mauricio, asesor de IZZI especialista en ventas por WhatsApp
            - Combinas framework AIDA + personalidad del cliente + proceso de venta estructurado

            ### ANÃLISIS DEL CLIENTE:
            - **Cliente:** {contact_name}
            - **Personalidad:** {personality_type} | **Etapa AIDA:** {aida_stage}
            - **Estilo:** {personality_styles[personality_type]['style']}

            ### ðŸŽ¯ DETECCIÃ“N INTELIGENTE DE INTENCIÃ“N:
            **ANALIZA si el cliente es:**
            - **PRECIO-ENFOCADO**: Busca "barato", "econÃ³mico", "presupuesto bajo", o pregunta directamente precios SIN mencionar necesidades especÃ­ficas
            - **CONSULTIVO**: Pregunta "quÃ© me recomienda", menciona familia/dispositivos/necesidades especÃ­ficas
            
            ### FRAMEWORK AIDA POR PERSONALIDAD:
            **ATENCIÃ“N:** D="Â¿Buscas el mejor internet? Oferta directa." | I="Â¡Hola! ðŸ˜Š Â¿Internet para toda la familia?" | S="Â¿Problemas con tu internet? SoluciÃ³n confiable." | C="Â¿MÃ¡s velocidad? Paquetes tÃ©cnicamente superiores."

            ### Paquetes IZZI (mantener precios exactos)
            - **2P (6 meses promociÃ³n):** 
            60MB (+80MB adicionales) Precio de lista $389, promociÃ³n de 3 meses $349
            80MB (+100MB adicionales) Precio de lista $510, promociÃ³n de 3 meses $419
            100MB (+150MB adicionales) Precio de lista $540, promociÃ³n de 3 meses $439
            150MB (+200MB adicionales) Precio de lista $610, promociÃ³n de 3 meses $509
            200MB (+500MB adicionales) Precio de lista $670, promociÃ³n de 3 meses $569
            500MB (+1000MB adicionales) Precio de lista $790, promociÃ³n de 3 meses $689
            1000MB Precio de lista $990, promociÃ³n de 3 meses $889

            - **3P (6 meses promociÃ³n):** 
            60MB (+80MB adicionales) Precio de lista $539, promociÃ³n de 6 meses $499
            80MB (+100MB adicionales) Precio de lista $690, promociÃ³n de 6 meses $599
            100MB (+150MB adicionales) Precio de lista $720, promociÃ³n de 6 meses $619
            150MB (+200MB adicionales) Precio de lista $790, promociÃ³n de 6 meses $689
            200MB (+500MB adicionales) Precio de lista $850, promociÃ³n de 6 meses $749
            500MB (+1000MB adicionales) Precio de lista $970, promociÃ³n de 6 meses $869
            1000MB Precio de lista $1,170, promociÃ³n de 6 meses $1,069
            
            **SI CLIENTE ES PRECIO-ENFOCADO:**
            1. Saluda segÃºn personalidad {personality_type}
            2. **OFRECE INMEDIATAMENTE**: "El mÃ¡s econÃ³mico es 60MB (+80MB adicionales) por $349 los primeros 3 meses, perfecto para WhatsApp y redes sociales"
            3. Solicita ubicaciÃ³n: "Presiona clip (ðŸ“Ž) â†’ 'UbicaciÃ³n' para compartir ubicaciÃ³n actual"
            4. Si acepta â†’ Solicita documentaciÃ³n directamente
            5. **NO hagas muchas preguntas** - ya decidiÃ³ que quiere lo barato

            **SI CLIENTE ES CONSULTIVO (Normal):**
            1. Saluda segÃºn personalidad {personality_type} y pregunta servicio actual
            2. **SOLICITA UBICACIÃ“N EXACTA:** "Presiona clip (ðŸ“Ž) â†’ 'UbicaciÃ³n' para compartir ubicaciÃ³n actual"
            3. Al recibir ubicaciÃ³n: confirma y agradece
            4. **PREGUNTAS NECESIDADES:** dispositivos, uso, personas, presupuesto, servicios adicionales
            5. **RECOMIENDA PAQUETE** especÃ­fico con precio exacto
            6. **Si acepta:** Solicita documentaciÃ³n:
            "Para continuar necesito:
            ðŸ‘¤ Nombre completo titular
            ðŸ  Comprobante domicilio  
            ðŸªª INE (frente y reverso)
            ðŸ“± TelÃ©fono titular
            ðŸ“ž TelÃ©fono referido
            ðŸ“§ Correo electrÃ³nico"

            ### ðŸ’° PAQUETE MÃS ECONÃ“MICO (Para precio-enfocados):
            **60MB (+80MB adicionales)** - $349 por 3 meses (precio regular $389)
            - Perfecto para WhatsApp, redes sociales, navegaciÃ³n bÃ¡sica
            - InstalaciÃ³n GRATIS incluida

            ### Promociones: InstalaciÃ³n GRATIS, MAX 12 meses, Apple TV+, VIX Premium, Domizzilia -$50/mes, Portabilidad, Sin plazos. TV+ $299, MÃ³vil +$79.
            ### Adicional
            - Izzi TV+ $299 (200 canales) con Sky Sports incluido
            - PromociÃ³n con MÃ³vil $79 Extra

            **Resumen:** {chr(10).join(conversation_summary) if conversation_summary else "Primera conversaciÃ³n"}
            **Recientes:** {chr(10).join(conversation_history[-10:]) if conversation_history else "Inicio"}

            ### INSTRUCCIONES:
            - Responde como {personality_type} en etapa {aida_stage}
            - Sigue proceso de venta paso a paso
            - Si cliente compartiÃ³ ubicaciÃ³n (Google Maps link), reconÃ³celo y continÃºa con preguntas de necesidades
            - MÃ¡ximo 2-3 oraciones
            - {personality_type}='I' usa 1 emoji ocasional

            Respuesta Sebastian Mauricio:
            """
        
        return prompt
    
    def generate_multiple_responses(self, contact_id, count=3):
        """
        Generate multiple response options for the same conversation
        All responses are based on the SAME isolated conversation
        """
        responses = []
        for i in range(count):
            logger.info(f"Generating response {i+1}/{count} for contact {contact_id}")
            result = self.generate_response(contact_id)
            if result['success']:
                responses.append(result['response'])
            else:
                # If one fails, try a fallback response
                responses.append(self.get_izzi_fallback_response())
        
        return {
            'success': True,
            'responses': responses,
            'contact_id': contact_id
        }
    
    def get_izzi_fallback_response(self):
        """
        IZZI-specific fallback responses when AI fails
        """
        fallbacks = [
            "Â¡Hola! ðŸ‘‹ Â¿Actualmente cuentas con una compaÃ±Ã­a o servicio de internet?",
            "Â¡Hola! Soy Sebastian de IZZI. Â¿Te interesa conocer nuestros paquetes de internet? ðŸ“±",
            "Â¡Hola! Â¿CÃ³mo estÃ¡s? Â¿Actualmente tienes servicio de internet en casa?"
        ]
        import random
        return random.choice(fallbacks)
    
    # Keep the original build_prompt method for backward compatibility if needed
    def build_prompt(self, contact, conversation_history):
        """
        Original generic prompt builder (kept for compatibility)
        Use build_izzi_prompt for IZZI-specific conversations
        """
        return self.build_izzi_prompt(contact, conversation_history)
    
    def build_conversation_summary(self, conversation_history):
        """Build a summary of key conversation points"""
        full_conversation = '\n'.join(conversation_history)
        
        summary_points = []
        
        # Check if client mentioned current internet service
        if any('megacable' in msg.lower() or 'totalplay' in msg.lower() or 'telmex' in msg.lower() or 'izzi' in msg.lower() for msg in conversation_history):
            summary_points.append("- Cliente ya mencionÃ³ su servicio actual de internet")
        
        # Check if location was shared
        if any('ubicaciÃ³n compartida' in msg.lower() or 'google.com/maps' in msg.lower() for msg in conversation_history):
            summary_points.append("- Cliente ya compartiÃ³ su ubicaciÃ³n")
        
        # Check if package was selected
        if any('3p' in msg.lower() or 'paquete' in msg.lower() or '$' in msg for msg in conversation_history):
            summary_points.append("- Cliente ya mostrÃ³ interÃ©s en un paquete especÃ­fico")
        
        # Check if client provided personal data
        if any('@' in msg and '.com' in msg for msg in conversation_history):
            summary_points.append("- Cliente ya proporcionÃ³ informaciÃ³n personal")
        
        return summary_points
    
    def detect_personality_type(self, conversation_history):
        """Detect customer personality type based on conversation patterns"""
        full_conversation = ' '.join(conversation_history).lower()
        
        # Dominant (D) - Direct, price-focused, short messages
        dominant_indicators = [
            'precio', 'cuanto cuesta', 'rapido', 'ya', 'directo', 'mejor oferta',
            'barato', 'mÃ¡s barato', 'no quiero', 'honestamente', 'nada mÃ¡s', 
            'solo quiero', 'necesito', 'quiero ya', 'ahora mismo', 'sin rodeos',
            'directo al grano', 'rÃ¡pido', 'inmediato', 'decidido', 'listo'
        ]
        dominant_score = sum(1 for indicator in dominant_indicators if indicator in full_conversation)
        
        # Influential (I) - Friendly, uses emojis, social language
        influential_indicators = [
            'familia', 'amigos', 'compartir', 'genial', 'perfecto', 'gracias',
            'excelente', 'increÃ­ble', 'fantÃ¡stico', 'buenÃ­simo', 'padre', 'chido',
            'quÃ© bueno', 'me gusta', 'suena bien', 'estÃ¡ padre', 'quÃ© padre',
            'social', 'todos', 'juntos', 'hijos', 'esposa', 'pareja'
        ]
        influential_score = sum(1 for indicator in influential_indicators if indicator in full_conversation)
        emoji_count = (full_conversation.count('ðŸ˜„') + full_conversation.count('ðŸ‘') + 
               full_conversation.count('ðŸ˜Š') + full_conversation.count('ðŸ˜') + 
               full_conversation.count('ðŸ¤—') + full_conversation.count('ðŸ‘Œ') +
               full_conversation.count('ðŸ’ª') + full_conversation.count('ðŸŽ‰'))
        influential_score += emoji_count
        
        # Steady (S) - Asks about reliability, service quality
        steady_indicators = [
            'servicio', 'confiable', 'problemas', 'soporte', 'calidad', 'estable',
            'seguro', 'garantÃ­a', 'respaldo', 'apoyo', 'ayuda', 'asistencia',
            'funciona bien', 'sin problemas', 'constante', 'duradero', 'fijo',
            'preocupa', 'dudas', 'seguridad', 'confianza', 'tranquilo'
        ]
        steady_score = sum(1 for indicator in steady_indicators if indicator in full_conversation)
        
        # Conscientious (C) - Technical questions, wants details
        conscientious_indicators = [
            'mbps', 'velocidad', 'tecnico', 'especificaciones', 'comparacion', 'diferencia',
            'detalles', 'informaciÃ³n', 'datos', 'nÃºmeros', 'estadÃ­sticas', 'anÃ¡lisis',
            'quÃ© incluye', 'cÃ³mo funciona', 'explicaciÃ³n', 'documentaciÃ³n', 
            'tÃ©rminos', 'condiciones', 'contrato', 'letra pequeÃ±a', 'opciones'
        ]
        conscientious_score = sum(1 for indicator in conscientious_indicators if indicator in full_conversation)
        
        # Determine dominant personality
        scores = {
            'D': dominant_score,
            'I': influential_score, 
            'S': steady_score,
            'C': conscientious_score
        }

        print(f"ðŸ§  PERSONALITY SCORES:")
        print(f"   D (Dominant): {dominant_score}")
        print(f"   I (Influential): {influential_score}")  
        print(f"   S (Steady): {steady_score}")
        print(f"   C (Conscientious): {conscientious_score}")
        
        detected_type = max(scores, key=scores.get) if max(scores.values()) > 0 else 'I'
        print(f"   âœ… DETECTED: {detected_type}")

        return max(scores, key=scores.get) if max(scores.values()) > 0 else 'I'  # Default to Influential
    
def detect_aida_stage(self, conversation_history):
    """Detect current AIDA stage based on conversation"""
    full_conversation = ' '.join(conversation_history).lower()
    
    # Action - Client ready to proceed, gave info, or accepted package
    if any(indicator in full_conversation for indicator in ['acepto', 'ok', 'si quiero', 'cuando vienen', 'cuanto tiempo']):
        return 'Action'
    
    # Desire - Asking about specific packages, prices, or showing strong interest
    if any(indicator in full_conversation for indicator in ['paquete', 'precio', 'cuanto cuesta', 'me interesa', '$']):
        return 'Desire'
    
    # Interest - Engaged, asking questions, shared location
    if any(indicator in full_conversation for indicator in ['ubicacion', 'cobertura', 'como funciona', 'que incluye']):
        return 'Interest'
    
    # Attention - Just starting conversation
    return 'Attention'